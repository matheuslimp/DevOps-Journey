# ğŸ— Arquitetura do Kubernetes e Manifests

De forma resumida, o Kubernetes tem dois blocos principais:

---

## ğŸ”¹ Plano de Controle (Control Plane)

Ã‰ o â€œcÃ©rebroâ€ do cluster. Componentes principais:

- **API Server** â†’ recebe todos os comandos (`kubectl`, manifests YAML).  
- **Scheduler** â†’ decide em qual nÃ³ (mÃ¡quina) cada Pod vai rodar.  
- **Controller Manager** â†’ garante que o estado desejado (descrito nos manifests) seja mantido.  
- **etcd** â†’ banco chave-valor onde o Kubernetes guarda o estado do cluster.  

---

## ğŸ”¹ Plano de Dados (Nodes)

SÃ£o as â€œmÃ¡quinasâ€ (virtuais ou fÃ­sicas) onde os containers rodam.  
Cada nÃ³ tem:

- **Kubelet** â†’ agente que conversa com o Control Plane.  
- **Kube-proxy** â†’ cuida da rede e dos Services.  
- **Container runtime** â†’ quem realmente roda os containers (Docker, containerd, CRI-O).  

---

## ğŸ“œ Onde entram os manifests?

Os manifests YAML sÃ£o a forma de vocÃª descrever o estado desejado do cluster.  
Quando vocÃª aplica um manifest (`kubectl apply -f arquivo.yaml`), o Kubernetes segue este fluxo:

1. VocÃª cria o manifest (Deployment, Service, etc.)  

Exemplo:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: minha-api
spec:
  replicas: 3
  template:
    spec:
      containers:
        - name: api
          image: minha-api:1.0


2. API Server recebe o manifest

  Ele valida se o YAML estÃ¡ correto e registra no etcd.

3. Controller Manager vÃª a diferenÃ§a entre o estado desejado e o real

  O manifest pede 3 Pods.
  O cluster ainda tem 0 Pods.
  O Controller cria 3 Pods.

4. Scheduler decide onde rodar cada Pod

  Ex: Pod 1 no Node A, Pod 2 no Node B, Pod 3 no Node C.

5. Kubelet do Node cria os containers usando o runtime (ex: containerd).
6 . Kube-proxy cria as regras de rede para que o Service aponte para esses Pods.

## RelaÃ§Ã£o entre componentes e manifests

| Manifest (YAML) | O que representa | Quem no Kubernetes cuida disso |
| :--- | :--- | :--- |
| **Pod** | Unidade bÃ¡sica de execuÃ§Ã£o de containers | Kubelet (no Node) |
| **Deployment** | Controlador que garante rÃ©plicas e updates | Controller Manager + Scheduler |
| **Service** | Rede estÃ¡vel para acessar Pods | kube-proxy |
| **ConfigMap / Secret** | ConfiguraÃ§Ãµes e segredos usados por containers | API Server / etcd |
| **PersistentVolumeClaim (PVC)** | SolicitaÃ§Ã£o de armazenamento persistente | Controller Manager + Storage backend |



ğŸš€ Caso real

VocÃª aplica 3 manifests:

deployment-api.yaml â†’ descreve 3 rÃ©plicas da sua aplicaÃ§Ã£o.

service-api.yaml â†’ cria um Service que expÃµe essa aplicaÃ§Ã£o.

deployment-mongo.yaml + service-mongo.yaml â†’ definem o banco e deixam acessÃ­vel para a API.

O Control Plane garante que tudo isso aconteÃ§a automaticamente.
VocÃª nÃ£o â€œsobe containersâ€ manualmente â€” vocÃª descreve o estado final e o Kubernetes mantÃ©m esse estado.
